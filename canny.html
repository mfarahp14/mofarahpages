<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Canny Edge â€“ Sticky Image</title>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

<style>
:root {
    --accent: #2563eb;
    --text-primary: #111827;
    --text-secondary: #6b7280;
    --border: #d1d5db;
}

/* Reset */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* Layout */
body {
    background: transparent;
    font-family: 'Inter', system-ui, sans-serif;
    min-height: 200vh;
}

.page-layout {
    display: flex;
    gap: 32px;
    align-items: flex-start;
    padding: 24px 16px;
}

/* LEFT: STICKY IMAGE */
.left-column {
    flex: 0 0 45%;
    position: sticky;
    top: 0;
    align-self: flex-start;
    height: 100vh;
}

.image-component {
    position: relative;
    height: 100%;
    max-height: 100vh;
    overflow: hidden;
    border-radius: 16px;
}

canvas {
    width: 100%;
    height: 100%;
    display: block;
}

/* Upload Overlay */
.upload-overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border: 2px dashed var(--border);
    cursor: pointer;
    background: rgba(255,255,255,0.7);
    transition: opacity 0.2s ease;
}

.upload-overlay.hidden {
    opacity: 0;
    pointer-events: none;
}

.upload-overlay h3 {
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.upload-overlay p {
    font-size: 0.85rem;
    color: var(--text-secondary);
}

/* Status + progress */
.image-status {
    position: absolute;
    top: 8px;
    left: 8px;
    right: 8px;
    display: flex;
    justify-content: space-between;
    pointer-events: none;
}

.image-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    color: var(--text-secondary);
}

.progress-indicator {
    height: 3px;
    background: var(--accent);
    position: absolute;
    bottom: 0;
    left: 0;
}

/* RIGHT COLUMN */
.right-column {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 160vh;
}

/* Extra space so scroll actually happens */
.spacer {
    height: 40vh;
}

/* Controls */
.controls-component {
    font-family: 'Inter', system-ui, sans-serif;
}

.controls-title {
    font-size: 1.3rem;
    margin-bottom: 1rem;
    font-weight: 500;
}

.control-group {
    margin-bottom: 1rem;
}

.control-label {
    display: flex;
    justify-content: space-between;
    font-weight: 500;
    font-size: 0.9rem;
    color: var(--text-primary);
}

.control-label span:last-child {
    color: var(--text-secondary);
}

.slider {
    width: 100%;
}

.stats {
    margin-top: 1.25rem;
    display: flex;
    gap: 20px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.description {
    margin-top: 2rem;
    font-size: 0.9rem;
    color: var(--text-secondary);
    line-height: 1.5;
}

/* Fade-in on scroll near bottom */
.controls-wrapper {
    opacity: 0;
    transform: translateY(24px);
    transition: all 0.4s ease;
}

.controls-wrapper.visible {
    opacity: 1;
    transform: translateY(0);
}

/* Mobile */
@media (max-width: 900px) {
    .page-layout {
        flex-direction: column;
    }
    .left-column {
        position: static; /* disable sticky on small screens */
        height: auto;
    }
    .image-component {
        max-height: 520px;
    }
    .spacer {
        height: 20vh;
    }
}
</style>
</head>

<body>

<div class="page-layout">

    <!-- LEFT: STICKY IMAGE -->
    <div class="left-column">
        <div class="image-component">
            <canvas id="displayCanvas" width="600" height="400"></canvas>

            <div class="upload-overlay" id="uploadOverlay">
                <h3>Use your own image</h3>
                <p>Click or drop an image (optional)</p>
                <input type="file" id="fileInputLeft" hidden accept="image/*">
            </div>

            <div class="image-status">
                <div class="image-label" id="imageLabel">Original</div>
            </div>

            <div class="progress-indicator" id="progressIndicator" style="width:0%"></div>
        </div>
    </div>

    <!-- RIGHT: CONTROLS & COPY -->
    <div class="right-column">

        <div class="spacer"></div>

        <div id="controlsWrapper" class="controls-wrapper">
            <div class="controls-component">

                <div class="controls-title">Play with the edges</div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Min Threshold</span>
                        <span id="minThresholdValue">50</span>
                    </div>
                    <input type="range" id="minThreshold" class="slider" min="0" max="255" value="50">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Max Threshold</span>
                        <span id="maxThresholdValue">150</span>
                    </div>
                    <input type="range" id="maxThreshold" class="slider" min="0" max="255" value="150">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Blur Amount</span>
                        <span id="blurValue">1.4</span>
                    </div>
                    <input type="range" id="gaussianBlur" class="slider" min="0" max="5" step="0.1" value="1.4">
                </div>

                <div class="stats">
                    <div id="edgePixels">-- edges</div>
                    <div id="edgeDensity">-- % edge density</div>
                </div>

                <div class="description">
                    Scroll the page to morph from the original image to the edge map.
                    The canvas on the left stays pinned so you always see the transformation.
                    Adjust thresholds and blur to change how aggressive the edges are.
                </div>
            </div>
        </div>

    </div>

</div>

<script>
/* === CONFIG: put your starting image here === */
const DEFAULT_IMAGE_URL = "https://mfarahp14.github.io/mofarahpages/assets/your-image.jpg"; 
// replace with an actual image in your repo (e.g. assets/mohface.jpg)

/* Simple canny-ish pipeline */
class Canny {
  constructor() {
    this.c = document.getElementById("displayCanvas");
    this.x = this.c.getContext("2d");
    this.width = this.c.width;
    this.height = this.c.height;
    this.original = null;
    this.edges = null;

    this.min = 50;
    this.max = 150;
    this.blur = 1.4;

    this.bindUpload();
    this.loadDefaultImage();
    window.addEventListener("scroll", () => this.updateTransition());
  }

  bindUpload() {
    const input = document.getElementById("fileInputLeft");
    const overlay = document.getElementById("uploadOverlay");
    overlay.onclick = () => input.click();
    overlay.ondragover = e => { e.preventDefault(); };
    overlay.ondrop = e => {
      e.preventDefault();
      if (e.dataTransfer.files[0]) this.loadFromFile(e.dataTransfer.files[0]);
    };
    input.onchange = e => this.loadFromFile(e.target.files[0]);
  }

  loadDefaultImage() {
    if (!DEFAULT_IMAGE_URL) return;
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
      this.drawImageFit(img);
      document.getElementById("uploadOverlay").classList.add("hidden");
    };
    img.src = DEFAULT_IMAGE_URL;
  }

  loadFromFile(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = e => {
      const img = new Image();
      img.onload = () => {
        this.drawImageFit(img);
        document.getElementById("uploadOverlay").classList.add("hidden");
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  }

  drawImageFit(img) {
    const cw = this.width, ch = this.height;
    const scale = Math.min(cw / img.width, ch / img.height);
    const sw = img.width * scale;
    const sh = img.height * scale;
    const ox = (cw - sw) / 2;
    const oy = (ch - sh) / 2;

    this.x.clearRect(0, 0, cw, ch);
    this.x.fillStyle = "#f3f4f6";
    this.x.fillRect(0, 0, cw, ch);
    this.x.drawImage(img, ox, oy, sw, sh);

    this.original = this.x.getImageData(0, 0, cw, ch);
    this.runEdgeDetection();
  }

  runEdgeDetection() {
    if (!this.original) return;
    const w = this.width, h = this.height;
    const src = this.original.data;
    const gray = new Uint8Array(w * h);

    // Grayscale
    for (let i = 0; i < src.length; i += 4) {
      gray[i / 4] = 0.299 * src[i] + 0.587 * src[i + 1] + 0.114 * src[i + 2];
    }

    const blurred = this.blur > 0 ? this.blurGray(gray, w, h, this.blur) : gray;

    // Threshold-based edge mask
    const out = new ImageData(w, h);
    let count = 0;
    for (let i = 0; i < blurred.length; i++) {
      const v = blurred[i];
      const e = (v >= this.min && v <= this.max) ? 255 : 0;
      out.data[i * 4] = e;
      out.data[i * 4 + 1] = e;
      out.data[i * 4 + 2] = e;
      out.data[i * 4 + 3] = 255;
      if (e) count++;
    }

    this.edges = out;

    const total = w * h;
    document.getElementById("edgePixels").textContent =
      count.toLocaleString() + " edges";
    document.getElementById("edgeDensity").textContent =
      ((count / total) * 100).toFixed(1) + " % edge density";

    this.updateTransition();
  }

  blurGray(data, w, h, sigma) {
    const r = Math.max(1, Math.round(sigma));
    const result = new Uint8Array(w * h);

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        let sum = 0, cnt = 0;
        for (let dy = -r; dy <= r; dy++) {
          for (let dx = -r; dx <= r; dx++) {
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
              sum += data[ny * w + nx];
              cnt++;
            }
          }
        }
        result[y * w + x] = sum / cnt;
      }
    }
    return result;
  }

  updateTransition() {
    if (!this.original || !this.edges) return;
    const maxScroll = document.body.scrollHeight - window.innerHeight;
    const p = maxScroll > 0 ? Math.min(1, Math.max(0, window.scrollY / maxScroll)) : 0;

    const mix = new ImageData(this.width, this.height);
    const o = this.original.data;
    const e = this.edges.data;
    const m = mix.data;

    for (let i = 0; i < m.length; i += 4) {
      m[i]   = o[i]   * (1 - p) + e[i]   * p;
      m[i+1] = o[i+1] * (1 - p) + e[i+1] * p;
      m[i+2] = o[i+2] * (1 - p) + e[i+2] * p;
      m[i+3] = 255;
    }

    document.getElementById("progressIndicator").style.width = (p * 100) + "%";
    document.getElementById("imageLabel").textContent =
      p < 0.1 ? "Original" : p > 0.9 ? "Edges" : Math.round(p * 100) + "%";

    this.x.putImageData(mix, 0, 0);
  }
}

const canny = new Canny();

/* Sliders */
document.getElementById("minThreshold").oninput = e => {
  canny.min = parseFloat(e.target.value);
  document.getElementById("minThresholdValue").textContent = e.target.value;
  canny.runEdgeDetection();
};

document.getElementById("maxThreshold").oninput = e => {
  canny.max = parseFloat(e.target.value);
  document.getElementById("maxThresholdValue").textContent = e.target.value;
  canny.runEdgeDetection();
};

document.getElementById("gaussianBlur").oninput = e => {
  canny.blur = parseFloat(e.target.value);
  document.getElementById("blurValue").textContent = e.target.value;
  canny.runEdgeDetection();
};

/* Reveal controls near bottom of scroll */
const controls = document.getElementById("controlsWrapper");
window.addEventListener("scroll", () => {
  if (window.scrollY + window.innerHeight > document.body.scrollHeight - 150) {
    controls.classList.add("visible");
  }
});
</script>

</body>
</html>
